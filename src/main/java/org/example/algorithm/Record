想看面试准备过程的在这：
TimothyL：一个大龄博士的刷题转码之路
前言：
这是本人在7个月刷了500道Leetcode题目并成功拿到几家北美Software Engineer Offer之后总结的Leetcode高频面试题目分类总结。这篇是高频题目的概述性总结，以后有时间打算单独给每个门类写一个详细的总结。希望对准备刷题面试的你有所帮助吧，谢谢！
注：本文一共200多道题，算上一些附加的衍生题差不多有250+，基本上很少有easy题目，大部分都是medium，少部分hard，按照大多数人30% Easy，60% Medium， 10% Hard的刷题标准，刷好下面全部的题目相当于300题，刷好足够应对大部分的算法面试了。如果你对算法与数据结构基础知识掌握的不够的情况下，先按照下面文章说提到的基础补好再开始刷对应门类的题目，不然很容易“一个人一包烟，一道题目刷一天”。
注：作者在北美各个大厂几乎全部面过，G家 A家 U家之类的大厂offer也都拿到过，可以确定刷好本文中的所有题以及掌握每道题对应知识点可以应对绝大多数的码农算法面试了。
如果题目/答案看不懂又不喜欢看discussion的话，现在有很多视频资源可以看。个人比较喜欢花花酱的讲解（花花酱的表世界的个人空间_哔哩哔哩_Bilibili）， 墙外的同学们也可以看关神的视频讲解（https://www.youtube.com/channel/UCY5Z0of98W-YSdmPgAe1DaA）。
不建议刷的题目类型：

非高频的hard题目，费时费力又很难在面试中遇到，性价比太低。
贪心法题目，每道题都不一样，解法没有通用性。
以下8个门类是面试中最常考的算法与数据结构知识点。

排序类（Sort）：
基础知识：快速排序（Quick Sort）， 归并排序（Merge Sort）的原理与代码实现。需要能讲明白代码中每一行的目的。快速排序时间复杂度平均状态下O（NlogN），空间复杂度O（1），归并排序最坏情况下时间复杂度O（NlogN），空间复杂度O（N）
入门题目：
Leetcode 148. Sort List # 值得多看几次
Leetcode 56. Merge Intervals
Leetcode 27. Remove elements
进阶题目：
Leetcode 179. Largest Number
Leetcode 75. Sort Colors
Leetcode 215. Kth Largest Element # 很经典的QuickSelect的题目 里面第一次看到了dummy的用法 但是并没有发现dummy呀
Leetcode 4. Median of Two Sorted Arrays # 太难了 后面再看吧 妈的终于 搞定了 不对 应该是看懂了 后面再复习的时候自己再写一遍 很多点都值得思考
注意：后两题是与快速排序非常相似的快速选择（Quick Select）算法，面试中很常考

链表类（Linked List）：

基础知识：链表如何实现，如何遍历链表。链表可以保证头部尾部插入删除操作都是O（1），查找任意元素位置O（N）
基础题目：
Leetcode 206. Reverse Linked List
Leetcode 876. Middle of the Linked List
注意：快慢指针和链表反转几乎是所有链表类问题的基础，尤其是反转链表，代码很短，建议直接背熟。

进阶题目:
Leetcode 160. Intersection of Two Linked Lists
Leetcode 141. Linked List Cycle (Linked List Cycle II)
Leetcode 92. Reverse Linked List II
Leetcode 328. Odd Even Linked List

堆（Heap or Priority Queue）、栈（Stack）、队列（Queue）、哈希表类（Hashmap、Hashset）：
基础知识：各个数据结构的基本原理，增删查改复杂度。
Queue题目：
Leetcode 225. Implement Stack using Queues
Leetcode 346. Moving Average from Data Stream  # done 思想很简单，细节要注意挺多 比如queueSize
Leetcode 281. Zigzag Iterator # leetcode plus // yue 主要那个k给我傻到了 行了知道了
Leetcode 1429. First Unique Number # leetcode plus 这些题好像都不常见 done; 通过哈希去判断是否重复，重点是出入队的条件
// =================
Leetcode 54. Spiral Matrix
Leetcode 362. Design Hit Counter # leetcode plus done

Stack题目：
Leetcode 155. Min Stack (follow up Leetcode 716 Max Stack # leetcode plus)
Leetcode 232. Implement Queue using Stacks
Leetcode 150. Evaluate Reverse Polish Notation
Leetcode 224. Basic Calculator II (I, II, III, IV) IV基本没遇到过 III也很少遇到
Leetcode 20. Valid Parentheses
Leetcode 1472. Design Browser History
Leetcode 1209. Remove All Adjacent Duplicates in String II
Leetcode 1249. Minimum Remove to Make Valid Parentheses
Leetcode 735. Asteroid Collision
Hashmap/ Hashset题目： 8题
Leetcode 1. Two Sum
Leetcode 146. LRU Cache 要求默写核心是双向链表 + 哈希 处理头尾之间链接的问题
Leetcode 128. Longest Consecutive Sequence
Leetcode 73. Set Matrix Zeroes
Leetcode 380. Insert Delete GetRandom O(1)
Leetcode 49. Group Anagrams
Leetcode 350. Intersection of Two Arrays II
Leetcode 299. Bulls and Cows
Leetcode 348 Design Tic-Tac-Toe    leetcode plus
Heap／Priority Queue题目： 12题
    第K个和前K个的区别，前者用快QuickSelect，后者要用Heap/PriorityQueue
    那什么情况下用快排？既然堆排更快的话？Heap的缺点是每次只能拿最小或者最大的数，但是QuickSort可以拿任意数
    如果需要区间内的最大值和最小值，就用双单调队列
Leetcode 973. K Closest Points ============> Done here 2022-02-06 now is 2022-10-13
Leetcode 347. Top k Largest Elements
Leetcode 23. Merge K Sorted Lists
Leetcode 264. Ugly Number II
Leetcode 1086. High Five            leetcode plus
Leetcode 88. Merge Sorted Arrays
Leetcode 692. Top K Frequent Words
Leetcode 378. Kth Smallest Element in a Sorted Matrix
Leetcode 295. Find Median from Data Stream
    中位数的题目求解一定要用double, 有两个容器互导一定要考虑两边的情况
Leetcode 767. Reorganize String
    最重要的是判断条件和插入方式 看到需要能回顾起来: Character的计数可以用arr做 -> 更geek
Leetcode 1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit (这个题用单调双端队列、TreeMap、双heap都可以) // 未完成
    滑动窗口适用条件: 数组 + 窗口 /  像题目中是要求窗口内最大值和最小值的差不是左右两端的，需要用到单调队列
    Sliding Window: 快速确定移动窗口中的最大最小值
    1. Each time expend the window to the right;
    2. Shrink the left side to make it valid;
    Key: query the min/max of a dynamic subarry
    因为left和right都只会走一次，所以可以直接for(int right = 0; right < length; right++) 的方式走
    两个单调队列可以在O(n)的时间维护一个区间内的最大最小值, 每个值都会加入两个队列，不同的是会把老油条挤走多少个
    这道题第一次做 还好有花花酱
Leetcode 895. Maximum Frequency Stack
    我们关心每个元素和他的频率 counter.
    我们关心maxFreq，需要用一个变量记载，之前不敢用是因为不知道maxFreq之间有没有断层，但是可以用手段避免断层，即判断有没有嘛
    配合第三个freq -> Stack两者之间的hashMap，通过stack.size()就能弥补断层
    有遇到这种情况还可以通过sequenceNumber++的方式在入栈的时候就把他的序号带进去，方便进行直接排序

二分法（Binary Search）：
基础知识：二分法是用来解法基本模板，时间复杂度logN；常见的二分法题目可以分为两大类，显式与隐式，
即是否能从字面上一眼看出二分法的特点：要查找的数据是否可以分为两部分，前半部分为X，后半部分为O
总结二分法的模板，以及注意点。二分法模版分成递归法和迭代法
测试的时候就拿example上 好好推演一遍
递归二分法在递归的时候因为确定nums[mid] !+ target, 所以递归调用的时候可以不用考虑mid节点，传mid + 1, right或者left, mid - 1;
二分法的方法起初有个核心的判断 left >= right && return -1;
具体看SimpleBinarySearch
显式二分法： 7题
Leetcode 34. Find First and Last Position of Element in Sorted Array
Leetcode 33. Search in Rotated Sorted Array
    // 数组一分为二，分成有序的和无序的，可能两部分都是有序的。看题画图ok?
    // 找出旋转点 下策
Leetcode 1095. Find in Mountain Array
    // 上一题的进阶题 回想一下 findPeek时候的痛苦[0, 1]
    // 记住!!peek的条件只是midValue > mid + 1Value 有顶点就一定有分别，到底分到左边还是右边，决定了返回是left还是right
    // while(left <= right) 什么时候要等号 while的条件里面有判断相等的时候需要等号
    // 算是大概弄懂了 我滴个呱呱 一天两道题
Leetcode 162. Find Peak Element
Leetcode 278. First Bad Version
Leetcode 74. Search a 2D Matrix
    感觉做的稀里糊涂的 边界问题搞死人 如果没有mountain的情况一律用 == return的方式
    主要是mountain
Leetcode 240. Search a 2D Matrix II
    // 明天再来想把 二分法真给我搞没了 有没有发现二刷没有像一刷那么难嘞 好像是哦而且写出来的代码也变简洁了
    // 四种解法
隐式二分法： 8题 // 问自己一句 能不能用二分
Leetcode 69. Sqrt(x)
    求两数的平均值，为了防止溢出 avg = left + (right - left) / 2;
    为了防止溢出，乘法最好改成除法
    return left or right? 取决于你对他们的定义
Leetcode 540. Single Element in a Sorted Array
Leetcode 644. Maximum Average Subarray II leetcode plus && 困难 && 微软也不考 算了把宝
Leetcode 528. Random Pick with Weight
    前缀和 + 二分法 前缀和也是这种权重概率类问题的解法之一
    // 真的简单 只是random.nextInt(range) 这个range不要弄错了 是最大值而不是最大Index
Leetcode 1300. Sum of Mutated Array Closest to Target // hi 真难受 不做了 // new message 铁子们 我跨过去了！！
    // 前缀和 记住就行了 每次判断的条件是前面的都加起来 后面的都变成nums[mid] 和target进行比较判断 k
    // 两个边界考虑起来很难吗?哥 还有close to target 小数的情况下会存在两个值 需要跟target进行比较 接近的那个才是答案
    // 以及核心的二分法判断式 突然觉得二分本身好简单 最重要的就是搞清楚我们在分什么 right代表了什么 很多都是mountain
Leetcode 1060. Missing Element in Sorted Array leetcode plus
    // 1. 考虑边界 2. 考虑核心表达式 3. 考虑返回的内容
Leetcode 1062. Longest Repeating Substring leetcode plus
    // 这题我没心情把他看懂
Leetcode 1891. Cutting Ribbons leetcode plus
// 所以后面这些题当时都没刷过了咯 = =
// 对二分的有感觉了

双指针（2 Pointer）： 19题
基础知识：常见双指针算法分为三类，同向（即两个指针都相同一个方向移动），
背向（两个指针从相同或者相邻的位置出发，背向移动直到其中一根指针到达边界为止），
相向（两个指针从两边出发一起向中间移动直到两个指针相遇）
背向双指针：(基本上全是回文串的题)
Leetcode 409. Longest Palindrome
Leetcode 125. Valid Palindrome
    奇怪的这题 代码感觉没错但是最后一个case过不了
Leetcode 5. Longest Palindromic Substring  这题的正解是dp 和上面一题1062一样 等dp把
    for字符串的每个位置，双指针向两侧游走，而且是同时兼顾单回和双回的情况，i, i -> i, i + 1
相向双指针：(以two sum为基础的一系列题)
Leetcode 1. Two Sum (这里使用的是先排序的双指针算法，不同于hashmap做法) 那就是暴力了 不用写了...
Leetcode 167. Two Sum II - Input array is sorted (都说用指针了 constant为常数 O(1) 如果用hash的话就是O(n)了)
    因为是排序的，指针从两头往中间走，根据和target的大小判断走哪个指针
Leetcode 15. 3Sum
    不能用哈希表做, 双指针要注意去重方式和index和num之间不要搞混
Leetcode 16. 3Sum Closest
    总体思路没错 注意细节, 如果有存在对比变量，对比变量的初始值要小心

Leetcode 18. 4Sum
    傻逼 注意溢出 long sum = (long) nums[first] + nums[second];
Leetcode 454. 4Sum II
    和上面一题不一样 这是四个数组 可以使用两两数组求和的办法 变成两数之和
    N个数组内数字求和的方式都可以这么做
Leetcode 277. Find the Celebrity  ======== > leetcode plus
    脑筋急转弯 我认识谁而谁又认识我
Leetcode 11. Container With Most Water
    如果最大的两个数在中间怎么办 [1, 2, 3, 24, 25, 5]; 需要让两个指针比较小的那个移动来碰碰运气 满足这种最极端需求的才是正确的解
    这道面试题考的可多了 要记住

同向双指针：（个人觉得最难的一类题，可以参考下这里 TimothyL：Leetcode 同向双指针/滑动窗口类代码模板）
// 搜类SlideWindowTemplate
Leetcode 283. Move Zeroes
    就算是简单的也要模拟一下输入，还是浮躁，我都能感觉到
    醉了 这么简单一道题 果然做数学题的时候脑子都要清楚
Leetcode 26. Remove Duplicate Numbers in Array
    和上一道题一起组成 什么移0️⃣去重剩下的数据放一边队伍
    返回值也要好好考虑考虑
Leetcode 395. Longest Substring with At Least K Repeating Characters
    离谱 我就这么被绕进去了
    往往中等题的思路都不复杂 如果能get到那个点
Leetcode 340. Longest Substring with At Most K Distinct Characters  leetcode plus
Leetcode 424. Longest Repeating Character Replacement *** 还需要再考虑看看 后面再来回味吧 先往前走走看
    // 可以说一遍过 核心还是搞清楚到底shrink的条件是什么 而且遇到的类型分成 只关心most 关心most和second 因为second会接盘 我是用most和other来的 必要的时候遍历获取second
Leetcode 76. Minimum Window Substring // 这tm就是变态 巨难 后面再好好看看题解 2020-10-18征服 yeah
    什么时候需要进行Math.max()的比较也要注意 比如这道题就在rightChar入范围的时候 上面一题就在完成shrink的时候
    这就是minimum和longest的区别
    有一点 minimum是每次shrink的时候都要对比 对比放在shrink的while里
    注意indexOf > -1, 注意不知道能不能重复的时候看一下 示例输入
Leetcode 3. Longest Substring Without Repeating Characters  ** 模板方法的基础版本
    统计的地方很奇怪 变成每次right + 1满足条件的时候
    好像也是，这里满足条件直接continue的 之前的longest
Leetcode 1004 Max Consecutive Ones III ===> done here
    完全没阻碍

BinaryTree
104 Maximum Depth of Binary Tree: 最简单
110 Balanced Binary Tree: 加上剪枝
// 还是应该每个地方都判断有没有不满足条件的需要向上传递 不然会误判，max的返回只会让下面的错误被掩盖
543 Diameter of Binary Tree
    不仅仅是左树和右数比，每棵子树的深度和最长可达是两个不同的值，需要引入额外变量
    也不能简单的把题意翻译成为，左子树和右子树的最高高度
437 Path SumII
    From top to bottom / choose or not choose
    SumWithRoot + Sum(left) + Sum(right);
    求总和 = target的可以把target传下去的时候每次扣减当前的val 共用一个参数
101 Symmetric Tree
    抓住核心思想 left.left = right.right; 以及几种判断true false的情况
1110 Delete Node And Return Forest dfs
    可以把要插入的值返回回去由上头进行插入
    带有父子关系断绝的就应该 root.left = helper(root.left); 这种方式
    要么把父亲被删除的信息带下去，要么先处理孩子，把孩子的信息返回再处理爸爸

FS优先搜索:
    广度优先:
        搜索最明显的特征是用到了队列结构，每次前进一步把可能性都加入队列，挨个poll出来执行
        也不一定是队列结构，只要步骤是有限的，比如树的左右子树节点，地图的上下左右，就可以在代码里面写死
        通过stack/queue和正序倒序可以做到比较灵活 可以替换掉递归结构 递归的消耗比较大 通过queue.size保证这一层的拿完不会拿到下一层

    深度优先搜索最明显的就是有一个map记录走过的路劲，先一条路走到底直到不满足条件就退回来换一边，递归和回溯
    DFS适合目标明确，BFS适合大范围查找
    递归的缺陷可以用
宽度优先搜索（BFS）：面试中最常考的 20题
基础知识：
常见的BFS用来解决什么问题？(1) 简单图（有向无向皆可）的最短路径长度，注意是长度而不是具体的路径（2）拓扑排序 （3） 遍历一个图（或者树）
BFS基本模板（需要记录层数或者不需要记录层数）
多数情况下时间复杂度空间复杂度都是O（N+M），N为节点个数，M为边的个数
基于树的BFS：不需要专门一个set来记录访问过的节点
Leetcode 102 Binary Tree Level Order Traversal 回忆起了以前做题的感觉
    迭代要比递归优秀的多 在性能上，可读性也不差
Leetcode 103 Binary Tree Zigzag Level Order Traversal
    先估计下这道题跟上道题难度差不多 inorder ? false : true
    略麻烦，主要是当层打印要顺序，加入queue的节点要逆序并且左右子树有差异，两者只能分开来了，poll出来的时候把val加进去，push到stack，从stack捞出来判断左右子树入queue

Leetcode 297 Serialize and Deserialize Binary Tree （很好的BFS和双指针结合的题）
    等等吧 最后有一关过不去了
Leetcode 314 Binary Tree Vertical Order Traversal
    核心是 HashMap<Integer, Queue<TreeNode>> 记录column和对应节点列表

基于图的BFS：（一般需要一个set来记录访问过的节点）
    图的一个问题 有可能图点和点之间是分开的 如果按照之前的bfs的写法遇到第一个点是空的[]就悲催了 直接GG
    for 在最外层 for (point: pointList) { while在里面 里面会波及到co节点 并且把未被处理过的co节点offer进去进行传播 }
Leetcode 200. Number of Islands
Leetcode 133. Clone Graph
Leetcode 127. Word Ladder
Leetcode 490. The Maze
Leetcode 323. Connected Component in Undirected Graph
Leetcode 130. Surrounded Regions
Leetcode 752. Open the Lock
Leetcode 815. Bus Routes
Leetcode 1091. Shortest Path in Binary Matrix
Leetcode 542. 01 Matrix ✅
    一开始想的方案是bfs广度优先，那复杂度会变成恐怖的O(m x n);
    简单的方法是，我们从左上到右下进行一次动态搜索，再从右下到左上进行一次动态搜索。两次动态搜索即可完成四个方向上的查找
    再反思，对于这种像波浪扩散的是不是都可以进行两次动态，左上到右下一次，右下到左上一次;
    步骤 初始化res[][] fill Integer.MAX_VALUE 因为要找最小的
    在左上到右下过程中是判断上方和左方来的 + 1 注意溢出判断
    在右下到左上过程中还要多带一个判断自己，即自己、右方、下方三者一起判断min
Leetcode 1293. Shortest Path in a Grid with Obstacles Elimination
拓扑排序：（https://zh.wikipedia.org/wiki/%E6%8B%93%E6%92%B2%E6%8E%92%E5%BA%8F）
Leetcode 207 Course Schedule （I, II）
Leetcode 444 Sequence Reconstruction
Leetcode 269 Alien Dictionary
Leetcode 310 Minimum Height Trees
Leetcode 366 Find Leaves of Binary Tree

深度优先搜索（DFS）：面试中最常考的
基础知识：
常见的DFS用来解决什么问题？(1) 图中（有向无向皆可）的符合某种特征（比如最长）的路径以及长度（2）排列组合（3） 遍历一个图（或者树）（4）找出图或者树中符合题目要求的全部方案
DFS基本模板（需要记录路径，不需要返回值 and 不需要记录路径，但需要记录某些特征的返回值）
除了遍历之外多数情况下时间复杂度是指数级别，一般是O(方案数×找到每个方案的时间复杂度)
递归题目都可以用非递归迭代的方法写，但一般实现起来非常麻烦
基于树的DFS：需要记住递归写前序中序后序遍历二叉树的模板
Leetcode 226 Invert Binary Tree
Leetcode 951 Flip Equivalent Binary Trees
Leetcode 124 Binary Tree Maximum Path Sum
Leetcode 236 Lowest Common Ancestor of a Binary Tree (相似题：235、1650)
Leetcode 105 Construct Binary Tree from Preorder and Inorder Traversal
Leetcode 987 Vertical Order Traversal of a Binary Tree
Leetcode 1485 Clone Binary Tree With Random Pointer
Leetcode 572 Subtree of Another Tree
Leetcode 863 All Nodes Distance K in Binary Tree
二叉搜索树（BST）：BST特征：中序遍历为单调递增的二叉树，换句话说，根节点的值比左子树任意节点值都大，比右子树任意节点值都小，增删查改均为O（h）复杂度，h为树的高度；注意不是所有的BST题目都需要递归，有的题目只需要while循环即可
Leetcode 230 Kth Smallest element in a BST
Leetcode 98 Validate Binary Search Tree
Leetcode 270 Cloest Binary Search Tree Value
Leetcode 235 Lowest Common Ancestor of a Binary Search Tree
Leetcode 669 Trim a Binary Search Tree
Leetcode 700 Search in a Binary Search Tree
Leetcode 108 Convert Sorted Array to Binary Search Tree
Leetcode 333 Largest BST Subtree (与98类似)
Leetcode 285 Inorder Successor in BST (I, II)
基于图的DFS: 和BFS一样一般需要一个set来记录访问过的节点，避免重复访问造成死循环; Word XXX 系列面试中非常常见，例如word break，word ladder，word pattern，word search。
Leetcode 341 Flatten Nested List Iterator (339 364)
Leetcode 394 Decode String
Leetcode 51 N-Queens (I II基本相同)
Leetcode 291 Word Pattern II (I为简单的Hashmap题)
Leetcode 126 Word Ladder II （I为BFS题目）
Leetcode 93 Restore IP Addresses
Leetcode 22 Generate Parentheses
Leetcode 586 Score of Parentheses
Leetcode 301 Remove Invalid Parentheses
Leetcode 37 Sodoku Solver
Leetcode 212 Word Search II （I, II）
Leetcode 1087 Brace Expansion
Leetcode 399 Evaluate Division
Leetcode 1274 Number of Ships in a Rectangle
Leetcode 1376 Time Needed to Inform All Employees
Leetcode 694 Number of Distinct Islands
Leetcode 131 Palindrome Partitioning
基于排列组合的DFS: 其实与图类DFS方法一致，但是排列组合的特征更明显
Leetcode 17 Letter Combinations of a Phone Number
Leetcode 39 Combination Sum（I, II, III相似， IV为动态规划题目）
Leetcode 78 Subsets （I, II 重点在于如何去重）
Leetcode 46 Permutation (I, II 重点在于如何去重)
Leetcode 77 Combinations (I, II 重点在于如何去重)
Leetcode 698 Partition to K Equal Sum Subsets
Leetcode 526 Beautiful Arrangement (similar to 46)
记忆化搜索（DFS + Memoization Search）：算是动态规划的一种，递归每次返回时同时记录下已访问过的节点特征，避免重复访问同一个节点，可以有效的把指数级别的DFS时间复杂度降为多项式级别; 注意这一类的DFS必须在最后有返回值，不可以用排列组合类型的DFS方法写; for循环的dp题目都可以用记忆化搜索的方式写，但是不是所有的记忆化搜索题目都可以用for循环的dp方式写。
Leetcode 139 Word Break II
Leetcode 72 Edit Distance
Leetcode 377 Combination Sum IV ✅
Leetcode 1235 Maximum Profit in Job Scheduling
Leetcode 1335 Minimum Difficulty of a Job Schedule
Leetcode 1216 Valid Palindrome III
Leetcode 97 Interleaving String
Leetcode 472 Concatenated Words
Leetcode 403 Frog Jump
Leetcode 329 Longest Increasing Path in a Matrix

前缀和（Prefix Sum）
基础知识：前缀和本质上是在一个list当中，用O（N）的时间提前算好从第0个数字到第i个数字之和，在后续使用中可以在O（1）时间内计算出第i到第j个数字之和，一般很少单独作为一道题出现，而是很多题目中的用到的一个小技巧
常见题目：
Leetcode 53 Maximum Subarray
Leetcode 1423 Maximum Points You Can Obtain from Cards
Leetcode 1031 Maximum Sum of Two Non-Overlapping Subarrays
Leetcode 523 Continuous Subarray Sum
Leetcode 304 Range Sum Query 2D - Immutable
以上内容皆为面试中高频的知识点，以下知识点和题目在面试中属于中等频率（大概面10道题会遇到一次），时间不足的情况下，请以准备上面的知识点为主。
=====================================================================================================================

并查集（Union Find）：把两个或者多个集合合并为一个集合
基础知识：如果数据不是实时变化，本类问题可以用BFS或者DFS的方式遍历，如果数据实时变化（data stream）则并查集每次的时间复杂度可以视为O（1）；需要牢记合并与查找两个操作的模板
常见题目：
Leetcode 721 Accounts Merge
Leetcode 547 Number of Provinces
Leetcode 737 Sentence Similarity II
Leetcode 305 Number of Islands II

字典树（Trie）
基础知识：（https://zh.wikipedia.org/wiki/Trie）；多数情况下可以通过用一个set来记录所有单词的prefix来替代，时间复杂度不变，但空间复杂度略高
常见题目：
Leetcode 208 Implement Trie (Prefix Tree)
Leetcode 211 Design Add and Search Words Data Structure
Leetcode 1268 Search Suggestions System
Leetcode 212 Word Search II

单调栈与单调队列（Monotone Stack／Queue）
基础知识：单调栈一般用于解决数组中找出每个数字的第一个大于／小于该数字的位置或者数字；单调队列只见过一道题需要使用；不论单调栈还是单调队列，单调的意思是保留在栈或者队列中的数字是单调递增或者单调递减的
常见题目：
Leetcode 85 Maximum Rectangle
Leetcode 84 Largest Rectangle in Histogram
Leetcode 907 Sum of Subarray Minimums (与84类似)
Leetcode 739 Daily Temperatures
Leetcode 901 Online Stock Span
Leetcode 503 Next Greater Element II
Leetcode 239 Sliding Window Maximum （唯一的单调队列题）

扫描线算法（Sweep Line）
基础知识：一个很巧妙的解决时间安排冲突的算法，本身比较容易些也很容易理解
常见题目：
Leetcode 253 Meeting Room II（Meeting Room I也可以使用）
Leetcode 218 The Skyline Problem
Leetcode 759 Employee Free Time

TreeMap
基础知识：基于红黑树（平衡二叉搜索树）的一种树状 hashmap，增删查改、找求大最小均为logN复杂度，Python当中可以使用SortedDict替代；SortedDict继承了普通的dict全部的方法，除此之外还可以peekitem(k)来找key里面第k大的元素，popitem(k)来删除掉第k大的元素，弥补了Python自带的heapq没法logN时间复杂度内删除某个元素的缺陷；最近又在刷一些hard题目时候突然发现TreeMap简直是个神技，很多用别的数据结构写起来非常麻烦的题目，TreeMap解决起来易如反掌。
常见题目：
Leetcode 729 My Calendar I
Leetcode 981 Time Based Key-Value Store
Leetcode 846 Hand of Straights
Leetcode 218 The Skyline Problem
Leetcode 480. Sliding Window Median (这个题用TreeMap超级方便)
Leetcode 318 Count of Smaller Numbers After Self (这个题线段树、二分索引树、TreeMap都可以)

动态规划（Dynamic Programming）
基础知识：这里指的是用for循环方式的动态规划，非Memoization Search方式。DP可以在多项式时间复杂度内解决DFS需要指数级别的问题。常见的题目包括找最大最小，找可行性，找总方案数等，一般结果是一个Integer或者Boolean。动态规划有很多分支，暂时还没想好怎么去写这部分，后面想好了再具体写吧。
常见题目：
    最重要的是状态转移方程 dp[i] = dp[i - 1] + dp[i - 2]; 根据关联情况决定到底要用多少的存储空间，这里n只跟n - 1, n - 2相关, 所以只要三个指针
Leetcode 674 Longest Continuous Increasing Subsequence (接龙型dp)
Leetcode 62 Unique Paths II
Leetcode 70 Climbing Stairs ✅
Leetcode 198 House Robber ✅
Leetcode 64 Minimum Path Sum ✅
    状态转移方程是 Math.min(pos[row - 1][column], pos[row][column - 1]) + grid[row][column];
    if (i == 0) else (j == 0) else {};
    二维存储空间的dp 和一维存储空间的dp 因为for for是一行行下去的，当前一行的值只和上一行有关系，所以可以直接在一行里更新
    如果遇到从左侧来的 dp[j] = dp[j - 1] + value, 如果遇到从上侧来的 dp[j] = dp[j] + value;
    这道题里是顺序覆盖，后面还会遇到需要倒序覆盖的
Leetcode 368 Largest Divisible Subset (接龙型dp)
Leetcode 300 Longest Increasing Subsequence (接龙型dp)
Leetcode 354 Russian Doll Envelopes (接龙型dp， 300的2D版)
Leetcode 256 Paint House
Leetcode 121 Best Time to Buy and Sell Stock
Leetcode 55 Jump Game
Leetcode 45 Jump Game II
Leetcode 132 Palindrome Partitioning II
Leetcode 312 Burst Balloons (区间型dp)
Leetcode 1143 Longest Common Subsequence (前缀型dp)
Leetcode 1062 Longest Repeating Substring (dp方法与longest common substring一致)
Leetcode 718 Maximum Length of Repeated Subarray (和1062本质上一样)
Leetcode 174 Dungeon Game
Leetcode 115 Distinct Subsequences
Leetcode 72 Edit Distance
Leetcode 91 Decode Ways
Leetcode 639 Decode Ways II
Leetcode 712 Minimum ASCII Delete Sum for Two Strings
Leetcode 221 Maximal Square ✅ 左上和右下
Leetcode 1277 Count Square Submatrices with All Ones (可以使用221一样的解法)
Leetcode 213 House Robber II
Leetcode 740 Delete and Earn
Leetcode 87 Scramble String
Leetcode 1140 Stone Game II
Leetcode 322 Coin Change
Leetcode 518 Coin Change II (01背包型)
Leetcode 1048 Longest String Chain
Leetcode 44 Wildcard Matching
Leetcode 10 Regular Expression Matching
Leetcode 32 Longest Valid Parentheses
Leetcode 1235 Maximum Profit in Job Scheduling (DP + binary search)
Leetcode 1043 Partition Array for Maximum Sum
Leetcode 926 Flip String to Monotone Increasing

// 翻转链表? 部分节点翻转多次链表?